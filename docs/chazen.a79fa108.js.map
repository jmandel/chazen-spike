{"version":3,"sources":["index.js"],"names":["log","l","window","document","getElementById","innerHTML","console","onerror","message","file","line","col","error","addEventListener","e","QUEUE_DELAY","FADE_TIME","module","hot","accept","location","reload","AudioContext","webkitAudioContext","resume","audioCtx","mapped","Array","keys","map","k","padStart","o","fetch","then","or","arrayBuffer","buffer","byteLength","Promise","resolve","reject","decodeAudioData","decodedData","err","all","soundBuffers","startTime","currentTime","duration","Math","min","apply","b","durationMs","currentIteration","plays","ensureNextSegment","now","which","absoluteOffset","nextSegmentTime","ceil","source","createBufferSource","gainNode","createGain","connect","destination","gain","setValueAtTime","start","filter","p","forEach","stop","concat","enqueue","iteration","maxValue","offset","floor","exponentialRampToValueAtTime","setTimeout","setInterval"],"mappings":"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","file":"chazen.a79fa108.js","sourceRoot":"..","sourcesContent":["window.onerror = function (message, file, line, col, error) {\n   log(\"Error occurred: \" + error.message);\n   return false;\n};\n\nwindow.addEventListener(\"error\", function (e) {\n   log(\"Error occurred: \" + e.error.message);\n   return false;\n})\n\nfunction log(l){\n  const log = window.document.getElementById(\"log\");\n  log.innerHTML += (l + \"<br>\");\n  console.log(l);\n}\n\nlog(\"Start\");\n\nconst QUEUE_DELAY = 0.05;\nconst FADE_TIME = 0.1;\n\nif (module.hot) {\n  module.hot.accept(function () {\n    location.reload();\n  });\n}\n\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\n\nlog(\"Create win.ac\");\nwindow.resume = function resume(){\n  window.audioCtx = new window.AudioContext();\n\n\nvar mapped = [...Array(10).keys()]\n  .map(k => (\"\" + (k + 1)).padStart(2, \"0\"))\n  .map(k => `sitting/sitting.${k}.mp3`)\n  .map(o => fetch(o).then(or => or.arrayBuffer()).then(buffer => {\n    log(\"One sb: \" + buffer.byteLength)\n    return new Promise((resolve, reject) => {\n      log(\"Making promise\" + audioCtx.decodeAudioData)\n      audioCtx.decodeAudioData(buffer, function (decodedData) {\n        log(\"decoded One sb\")\n        resolve(decodedData);\n      }, function(err){\n        log(\"decodeAudioData: \" + err);\n      });\n    })\n  }))\n\nlog(\"Make sbs\")\nPromise.all(mapped).then(soundBuffers => {\n\n  log(\"Got all promises\")\n  log(soundBuffers);\n  var startTime = audioCtx.currentTime;\n  window.soundBuffers = soundBuffers\n\n  var duration = Math.min.apply(null, soundBuffers.map(b => b.duration));\n  log(\"midur\", duration)\n  var durationMs = duration * 1000;\n  var currentIteration = 0;\n\n  var plays = [];\n\n  window.enqueue = function enqueue(iteration) {\n    var source = audioCtx.createBufferSource();\n    currentIteration = iteration;\n    source.buffer = soundBuffers[iteration];\n    var gainNode = audioCtx.createGain();\n    source.connect(gainNode);\n    gainNode.connect(audioCtx.destination);\n    gainNode.gain.setValueAtTime(0.0001, audioCtx.currentTime);\n    log(\"gmx\", gainNode.gain.maxValue)\n\n    var now = audioCtx.currentTime;\n    var absoluteOffset = (now - startTime);\n    var offset = absoluteOffset - duration * Math.floor(absoluteOffset / duration);\n\n    gainNode.gain.exponentialRampToValueAtTime(1.0, now + QUEUE_DELAY + FADE_TIME);\n    source.start(now + QUEUE_DELAY, offset + QUEUE_DELAY, duration - offset - QUEUE_DELAY);\n    log(plays)\n    plays.forEach(p => p[1].gain.exponentialRampToValueAtTime(0.0001, now + QUEUE_DELAY + FADE_TIME) && p[2].stop(now + QUEUE_DELAY + 2 * FADE_TIME));\n    plays = [\n      [now + QUEUE_DELAY, gainNode, source]\n    ];\n    ensureNextSegment();\n  }\n\n  enqueue(currentIteration);\n  setTimeout(() => (setInterval(() => {\n    ensureNextSegment(currentIteration);\n  }, durationMs * .50)), 100)\n\n  function nextSegmentFrom(which) {\n    return which;\n  }\n\n  function ensureNextSegment() {\n    var now = audioCtx.currentTime + QUEUE_DELAY;\n    var absoluteOffset = (now - startTime);\n    var nextSegmentTime = startTime + duration * Math.ceil(absoluteOffset / duration);\n\n    var source = audioCtx.createBufferSource();\n    log(\"Ensure next\", currentIteration, nextSegmentTime);\n    source.buffer = soundBuffers[nextSegmentFrom(currentIteration)];\n    var gainNode = audioCtx.createGain();\n    source.connect(gainNode);\n    gainNode.connect(audioCtx.destination);\n    gainNode.gain.setValueAtTime(1.0, audioCtx.currentTime);\n    source.start(nextSegmentTime, 0, duration);\n    plays.filter(p => p[0] == nextSegmentTime).forEach(p => p[2].stop())\n    plays = plays.filter(p => p[0] !== nextSegmentTime || p[0] < now - duration).concat([\n      [nextSegmentTime, gainNode, source]\n    ]);\n  }\n\n\n})\n}\n\n"]}